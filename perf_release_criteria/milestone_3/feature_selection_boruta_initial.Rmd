---
title: "Milestone 2: Feature Selection - Boruta"
output: html_notebook
---

```{r imports, echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
library(Boruta)
source('../lib/scoring.R')
```

# tl;dr
This analysis determines the relevant [covariates (features)](https://docs.google.com/document/d/1SfuanvmYmvmEFAdQ7Z5djDeLezdNB1TESqVmj93O8to/edit#heading=h.nwwrif453n80) to utilize for computationally intensive statistical matching algorithms proposed in the modeling approach for this [PRD](https://docs.google.com/document/d/1Ygz6MkudYHZjnDnD9Z97kUyFrvV3KGWsjXyPjddhHq0/edit#heading=h.lvb9l8gw2nee). 

This analysis is focused on utilizing `Boruta` as a initial pre-filter to the covariates, to narrow the feature selection search space.

```{r data_load, echo=FALSE}
file_name = 'df_train_validate_20191021.RData'
image_file_path = file.path('data', file_name)

# Pull from GCP if necessary
# Sys.setenv("GCS_DEFAULT_BUCKET" = "moz-fx-dev-subbeta",
#            "GCS_AUTH_FILE" = "moz-fx-dev-cdowhyglund-subBeta-788f8f0d4627.json")
# library(googleCloudStorageR)
# gcs_get_object(file.path('data', 'milestone2', file_name), saveToDisk = image_file_path, overwrite = TRUE)

load(image_file_path)
```

# Method

Apply `Boruta` to each performance covariate.

```{r var_def}
perf_metrics <- names(get_m2_metric_map())

set.seed(1234)
df_train_f_sm <- df_train_f %>%
   sample_n(80000)

df_fs <- df_train_f_sm %>%
   select(-perf_metrics) %>%
   select(-content_crashes) %>%
   select(-client_id) %>%
   select(-label) %>%
   select(-is_release) %>%
   select(-app_version)
```


```{r apply_boruta}
boruta_results <- list()

for (metric in perf_metrics){
  print(paste('Applying Boruta to ', metric))
   boruta.out <- Boruta(y = df_train_f_sm[[metric]], x=df_fs, doTrace=0)
  boruta_results[[metric]]  <- boruta.out
  # plot(boruta.out, cex.axis=.7, las=2, xlab="", main=metric) 
}
```

```{r boruta_plots}
for (metric in names(boruta_results)){
  plot(boruta_results[[metric]], cex.axis=.7, las=2, xlab="", main=metric) 
}
```

Find the top 5 ranking features per metric, and add to a list. 

```{r aggregate_features_5}
features_top5 <- NULL
for(metric in names(boruta_results)){
  features_top5 <- c(names(sort(apply(boruta_results[[metric]]$ImpHistory, 2, median), decreasing = TRUE)[1:5]), features_top5)
}

knitr::kable(data.frame(top5 = sort(c(unique(features_top5)))))
```

Increasing to 10:

```{r aggregate_features_10}
features_top10 <- NULL
for(metric in names(boruta_results)){
  features_top10 <- c(names(sort(apply(boruta_results[[metric]]$ImpHistory, 2, median), decreasing = TRUE)[1:10]), features_top10)
}

knitr::kable(data.frame(top10 = sort(c(unique(features_top10)))))
```


## Equal Labels

Equalize by label, then perform the above. 

```{r var_def_equal}
df_beta <- df_train_f %>% 
  filter(is_release == FALSE)
n_beta <- nrow(df_beta)
set.seed(1234)
df_rel <- df_train_f %>% 
  filter(is_release == TRUE) %>%
  sample_n(n_beta)

set.seed(1234)
df_train_f_sm_eq <- df_rel %>%
  bind_rows(df_beta) %>%
   sample_n(80000)

df_fs_eq <- df_train_f_sm_eq %>%
   select(-perf_metrics) %>%
   select(-content_crashes) %>%
   select(-client_id) %>%
   select(-label) %>%
   select(-is_release) %>%
   select(-app_version)
```

```{r apply_boruta_equal}
boruta_results_eq <- list()

for (metric in perf_metrics){
  print(paste('Applying Boruta to ', metric))
  boruta.out <- Boruta(y = df_train_f_sm_eq[[metric]], x=df_fs_eq, doTrace=0)
  boruta_results_eq[[metric]]  <- boruta.out
  # plot(boruta.out, cex.axis=.7, las=2, xlab="", main=metric) 
}
```

```{r boruta_plots_eq}
for (metric in names(boruta_results_eq)){
  plot(boruta_results_eq[[metric]], cex.axis=.7, las=2, xlab="", main=metric) 
}
```

```{r aggregate_features_5_eq}
features_top5 <- NULL
for(metric in names(boruta_results_eq)){
  features_top5 <- c(names(sort(apply(boruta_results_eq[[metric]]$ImpHistory, 2, median), decreasing = TRUE)[1:5]), features_top5)
}

knitr::kable(data.frame(top5 = sort(c(unique(features_top5)))))
```

Increasing to 10:

```{r aggregate_features_10_eq}
features_top10 <- NULL
for(metric in names(boruta_results_eq)){
  features_top10 <- c(names(sort(apply(boruta_results_eq[[metric]]$ImpHistory, 2, median), decreasing = TRUE)[1:10]), features_top10)
}

knitr::kable(data.frame(top10 = sort(c(unique(features_top10)))))
```



# Serialize and push to GCP
Save the resultant dataset and bootstrap samples to an R image. 

```{r serialize_dataset}
image_file_name <- paste('feature_selection_boruta_initial_', format(Sys.time(), "%Y%m%d"), '.RData', sep='')
image_file_path <- file.path('data', image_file_name)
save(df_fs, df_fs_eq, boruta_results, boruta_results_eq, file = image_file_path)

gcs_file_path <- file.path('data', 'milestone2', image_file_name)
```

Then push the results to GCP in the `moz-fx-dev-subbeta` bucket, under `r gcs_file_path`.

```{r gcp_storage_push, warning=FALSE}
Sys.setenv("GCS_DEFAULT_BUCKET" = "moz-fx-dev-subbeta",
           "GCS_AUTH_FILE" = "moz-fx-dev-cdowhyglund-subBeta-788f8f0d4627.json")

library(googleCloudStorageR)

upload_try <- gcs_upload(image_file_path, name = gcs_file_path)
upload_try
```
