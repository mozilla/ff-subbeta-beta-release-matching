---
title: "Feature Selection - Boruta"
author: "Mariana de Oliveira Santos Silva"
date: 'Last Updated: `r format(Sys.time(), "%B %d, %Y")`'
output: 
  html_document:
    theme: "flatly"
    toc: true
    toc_float: true
    code_folding: "hide"
    highlight: tango
---

```{r libraries, message=FALSE, warning=FALSE, include=FALSE}
## Loading the needed libraries

library(kableExtra)      # help you build common complex tables and manipulate table styles
library(DataExplorer)    # automated data exploration
library(tidyverse)       # for general data wrangling (includes readr and dplyr)
library(ggplot2)         # to draw statistical plots 
library(Boruta)          # to use relevant feature selection wrapper algorithm
library(ggthemes)
library(funModeling) 
library(corrplot)
library(MatchIt)
library(optmatch)
library(RItools)
library(magrittr)
library(tidyr)
library(tidyselect)
```

```{r data_load, echo=FALSE}
load("~/GitHub/ff-beta-release-matching/poc/matchIt/feature_engineering.RData")
```

# tl;dr

This analysis is focused on utilizing `Boruta` as a initial pre-filter to the covariates, to narrow the feature selection search space.

# Method

Apply `Boruta` to each performance covariate.

```{r var_def}
engagement <- c('active_hours','active_hours_max','uri_count','uri_count_max','search_count','search_count_max','num_pages','num_pages_max','daily_max_tabs','daily_max_tabs_max','daily_unique_domains','daily_unique_domains_max','daily_tabs_opened','daily_tabs_opened_max')

set.seed(1234)
df_train_sm <- df_train_encoder %>%
   sample_n(1000)

df_fs <- df_train_sm %>%
   select(-engagement) %>%
   select(-content_crashes) %>%
   select(-client_id) %>%
   select(-label_beta) %>%
   select(-label_release) %>%
   select(-is_release) %>%
   select(-app_version)
```

Boruta is a feature selection algorithm based on the random forest algorithm. In the process of deciding if a feature is important or not, some features may be marked as *Tentative*. Sometimes increasing the `maxRuns` can help resolve the *Tentativeness* of the feature.

```{r apply_boruta}
boruta_results <- list()
for (metric in engagement){
  print(paste('Applying Boruta to ', metric))
  boruta.out <- Boruta(y = df_train_sm[[metric]], x=df_fs, doTrace=0)
  boruta_results[[metric]]  <- boruta.out
  # plot(boruta.out, cex.axis=.7, las=2, xlab="", main=metric) 
}
```

```{r boruta_plots}
for (metric in names(boruta_results)){
  plot(boruta_results[[metric]], cex.axis=.7, las=2, xlab="", main=metric) 
}
```

Find the top 5 ranking features per metric, and add to a list. 

```{r aggregate_features_5}
features_top5 <- NULL
for(metric in names(boruta_results)){
  features_top5 <- c(names(sort(apply(boruta_results[[metric]]$ImpHistory, 2, median), decreasing = TRUE)[1:5]), features_top5)
}
knitr::kable(data.frame(top5 = sort(c(unique(features_top5)))))
```

Increasing to 10:

```{r aggregate_features_10}
features_top10 <- NULL
for(metric in names(boruta_results)){
  features_top10 <- c(names(sort(apply(boruta_results[[metric]]$ImpHistory, 2, median), decreasing = TRUE)[1:10]), features_top10)
}
knitr::kable(data.frame(top10 = sort(c(unique(features_top10)))))
```


## Equal Labels

Equalize by label, then perform the above. 

```{r var_def_equal}
df_beta <- df_train_encoder %>% 
  filter(label_beta == 1)
n_beta <- nrow(df_beta)
set.seed(1234)
df_rel <- df_train_encoder %>% 
  filter(label_beta == 0) %>%
  sample_n(n_beta)
set.seed(1234)
df_train_f_sm_eq <- df_rel %>%
  bind_rows(df_beta) %>%
   sample_n(1000)
df_fs_eq <- df_train_f_sm_eq %>%
   select(-engagement) %>%
   select(-content_crashes) %>%
   select(-client_id) %>%
   select(-label_beta) %>%
   select(-label_release) %>%
   select(-is_release) %>%
   select(-app_version)
```

```{r apply_boruta_equal}
boruta_results_eq <- list()
for (metric in engagement){
  print(paste('Applying Boruta to ', metric))
  boruta.out <- Boruta(y = df_train_f_sm_eq[[metric]], x=df_fs_eq, doTrace=0)
  boruta_results_eq[[metric]]  <- boruta.out
  # plot(boruta.out, cex.axis=.7, las=2, xlab="", main=metric) 
}
```

```{r boruta_plots_eq}
for (metric in names(boruta_results_eq)){
  plot(boruta_results_eq[[metric]], cex.axis=.7, las=2, xlab="", main=metric) 
}
```

```{r aggregate_features_5_eq}
features_top5 <- NULL
for(metric in names(boruta_results_eq)){
  features_top5 <- c(names(sort(apply(boruta_results_eq[[metric]]$ImpHistory, 2, median), decreasing = TRUE)[1:5]), features_top5)
}
knitr::kable(data.frame(top5 = sort(c(unique(features_top5)))))
```

Increasing to 10:

```{r aggregate_features_10_eq}
features_top10 <- NULL
for(metric in names(boruta_results_eq)){
  features_top10 <- c(names(sort(apply(boruta_results_eq[[metric]]$ImpHistory, 2, median), decreasing = TRUE)[1:10]), features_top10)
}
knitr::kable(data.frame(top10 = sort(c(unique(features_top10)))))
```

# Saving

```{r}
save.image(file = "feature_selection.RData")
```
